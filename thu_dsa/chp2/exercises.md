教材课后习题回答
==============

## Vector.D1

> 较之无序向量，有序向量的唯一化可以更快地完成。其中的原因如何理解和解释？

就找到雷同元素而言，对于无序向量，必须逐个遍历前面的元素，该过程的时间复杂度为`O(k)`，`k`为当前元素的秩；而对于有序向量，若存在雷同元素，则必然处于当前元素的周围，因此找到雷同元素的时间仅为`O(1)`。

此外，就删除雷同元素而言，无序向量必须将后面的元素逐个向前移动，时间复杂度是`O(n- k)`，`k`为当前元素的秩；而对于有序向量，可以在遍历的过程中直接定位当前元素最终的位置，从而一步将它移动到最后的位置，时间复杂度仅为`O(1)`。

## Vector.D2

> 各种查找结果出现的概率不均等时，查找长度应该如何定义和计算

平均查找长度应该定义为各个查找结果对应的查找长度的概率期望。计算的时候就按照定义来计算？感觉问题就相当复杂了。

## Vector.D3

> `fibSearch()`的内层`while`循环，至多能够连续执行几次？

三次。一般说来是两次，但是考虑到最后一次迭代有`fib(2) = fib(1)`，就是三次了。

举个例子，当前`lo = 0, hi = 4`，此时`hi - lo = 4 = fib(5) - 1`，因此`mid =
fib(4) - 1 = 2`。一次比较后，有`get(mid) < val`，转向右侧分支，更新`lo = mid +1 = 3`，此时`hi - lo = 1`。
+ 第一次内层循环，由于`fib.get() = 2 >= hi - lo`，调用`fib.prev()`，此时`fib.get() = 1`。
+ 第二次内层循环，由于`fib.get() = 1 >= hi - lo`，调用`fib.prev()`，此时`fib.get() = 1`。
+ 第三次内层循环，满足`fib.get() = 1 >= hi - lo`，调用`fib.prev()`，此时`fib.get() = 0`。
+ 第四次不再满足循环条件，退出内层循环。

> 改进本节所给的实现，使`Fibonacci`查找严格符合`search()`接口


